This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
assets/
  mb-logo.svg
src/
  core/
    types.ts
  modules/
    icon-rename/
      main.ts
    style-to-variable/
      main.ts
    index.ts
  ui/
    index.html
  main.ts
.gitattributes
.gitignore
build.js
CLAUDE.md
manifest.json
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules/**
dist/**
</file>

<file path="assets/mb-logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<!-- Placeholder; will be replaced by build copy from repo root if exists -->
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64" fill="none">
  <rect width="64" height="64" rx="12" fill="#111"/>
  <text x="50%" y="50%" text-anchor="middle" dominant-baseline="central" fill="#fff" font-family="Arial" font-size="22">MB</text>
  </svg>
</file>

<file path="src/core/types.ts">
export type ModuleId = 'style' | 'icons';

export interface UIMsg<T extends string = string, P = any> {
  module: ModuleId;
  type: T;
  payload?: P;
}

export interface UIPost {
  postMessage: (msg: any) => void;
}

export type Handler = (payload?: any) => Promise<void> | void;

export interface Module {
  id: ModuleId;
  name: string;
  init?: () => void; // opcional para registrar listeners (ex.: selectionchange)
  handlers: Record<string, Handler>;
}
</file>

<file path="src/modules/icon-rename/main.ts">
import type { Module } from '../../core/types';
import lucideNames from '../../../../mbIconRename/lucide-names.json';

function kebabToPascalCase(str: string) {
  return str
    .split('-')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
}

export const iconsModule: Module = {
  id: 'icons',
  name: 'Icon Rename',
  handlers: {
    'rename-icons': () => {
      const selectedNodes = figma.currentPage.selection;
      if (selectedNodes.length === 0) {
        figma.notify('Selecione pelo menos um componente.');
        return;
      }
      let renamedCount = 0;
      const invalidNames: string[] = [];
      for (const node of selectedNodes) {
        if (node.type === 'COMPONENT' || node.type === 'COMPONENT_SET') {
          const oldName = node.name;
          const newName = kebabToPascalCase(oldName);
          if ((lucideNames as string[]).includes(newName)) {
            node.name = newName;
            renamedCount++;
            // eslint-disable-next-line no-console
            console.log(`✅ Renomeado: "${oldName}" → "${newName}"`);
          } else {
            invalidNames.push(newName);
          }
        }
      }
      if (invalidNames.length > 0) {
        const formatted = JSON.stringify(invalidNames, null, 2);
        // eslint-disable-next-line no-console
        console.warn(`❌ Nomes inválidos (${invalidNames.length}) — copie e cole no lucide-names.json se forem válidos:\n${formatted}`);
      }
      figma.notify(`${renamedCount} renomeado(s), ${invalidNames.length} inválido(s).`);
      figma.ui.postMessage({ module: 'icons', type: 'done', invalidNames });
    }
  }
};
</file>

<file path="src/modules/style-to-variable/main.ts">
import type { Module } from '../../core/types';

const STYLE_PREFIX = 'colors/';
const VARIABLE_PREFIX = 'colors/';

function convertStyleNameToVariableName(styleName: string): string {
  if (!styleName.startsWith(STYLE_PREFIX)) return '';
  const token = styleName.slice(STYLE_PREFIX.length);
  return `${VARIABLE_PREFIX}${token}`;
}

let variableCache: Map<string, Variable> | null = null;

async function getVariableCache(): Promise<Map<string, Variable>> {
  if (!variableCache) {
    variableCache = new Map();
    const allVariables = await figma.variables.getLocalVariablesAsync();
    allVariables
      .filter((v) => v.resolvedType === 'COLOR' && v.name.startsWith(VARIABLE_PREFIX))
      .forEach((v) => variableCache!.set(v.name, v));
  }
  return variableCache;
}

async function countColorStyles(selection: readonly SceneNode[]): Promise<number> {
  let count = 0;
  async function countInNode(node: SceneNode) {
    if ('fillStyleId' in node && node.fillStyleId && typeof node.fillStyleId === 'string') {
      const style = await figma.getStyleByIdAsync(node.fillStyleId);
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) count++;
    }
    if ('strokeStyleId' in node && node.strokeStyleId && typeof node.strokeStyleId === 'string') {
      const style = await figma.getStyleByIdAsync(node.strokeStyleId);
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) count++;
    }
    if ('children' in node) {
      for (const child of node.children) await countInNode(child);
    }
  }
  for (const node of selection) await countInNode(node);
  return count;
}

async function convertStylesToVariables(selection: readonly SceneNode[]): Promise<{
  converted: number;
  failed: number;
  errors: string[];
}> {
  const variables = await getVariableCache();
  const result = { converted: 0, failed: 0, errors: [] as string[] };

  async function processNode(node: SceneNode) {
    if ('fillStyleId' in node && node.fillStyleId && typeof node.fillStyleId === 'string') {
      const style = await figma.getStyleByIdAsync(node.fillStyleId);
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) {
        const variableName = convertStyleNameToVariableName(style.name);
        const variable = variables.get(variableName);
        if (variable) {
          try {
            const fills = JSON.parse(JSON.stringify(node.fills));
            if (fills.length > 0) {
              fills[0] = figma.variables.setBoundVariableForPaint(fills[0], 'color', variable);
              node.fills = fills;
              result.converted++;
            }
          } catch (_e) {
            result.failed++;
            result.errors.push(`Failed to convert fill: ${style.name}`);
          }
        } else {
          result.failed++;
          if (!result.errors.includes(variableName)) result.errors.push(`Variable not found: ${variableName}`);
        }
      }
    }
    if ('strokeStyleId' in node && node.strokeStyleId && typeof node.strokeStyleId === 'string') {
      const style = await figma.getStyleByIdAsync(node.strokeStyleId);
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) {
        const variableName = convertStyleNameToVariableName(style.name);
        const variable = variables.get(variableName);
        if (variable) {
          try {
            const strokes = JSON.parse(JSON.stringify(node.strokes));
            if (strokes.length > 0) {
              strokes[0] = figma.variables.setBoundVariableForPaint(strokes[0], 'color', variable);
              node.strokes = strokes;
              result.converted++;
            }
          } catch (_e) {
            result.failed++;
            result.errors.push(`Failed to convert stroke: ${style.name}`);
          }
        } else {
          result.failed++;
          if (!result.errors.includes(variableName)) result.errors.push(`Variable not found: ${variableName}`);
        }
      }
    }
    if ('children' in node) {
      for (const child of node.children) await processNode(child);
    }
  }

  for (const node of selection) await processNode(node);
  return result;
}

function notifySelectionUpdate() {
  // Fire and forget
  countColorStyles(figma.currentPage.selection).then((count) => {
    figma.ui.postMessage({ module: 'style', type: 'selection-update', count, hasSelection: figma.currentPage.selection.length > 0 });
  });
}

export const styleModule: Module = {
  id: 'style',
  name: 'Styles → Variables',
  init() {
    figma.on('selectionchange', notifySelectionUpdate);
  },
  handlers: {
    'check-selection': async () => {
      notifySelectionUpdate();
    },
    convert: async () => {
      const selection = figma.currentPage.selection;
      if (selection.length === 0) {
        figma.ui.postMessage({ module: 'style', type: 'error', message: 'Nenhum elemento selecionado' });
        return;
      }
      const result = await convertStylesToVariables(selection);
      figma.ui.postMessage({ module: 'style', type: 'conversion-complete', ...result });
      if (result.failed === 0) figma.notify(`✅ ${result.converted} estilos convertidos`);
      else figma.notify(`Convertidos: ${result.converted} | Falhas: ${result.failed}`, { timeout: 5000 });
      // Refresh status
      notifySelectionUpdate();
    }
  }
};
</file>

<file path="src/modules/index.ts">
import type { Module } from '../core/types';
import { styleModule } from './style-to-variable/main';
import { iconsModule } from './icon-rename/main';

export const modules: Module[] = [styleModule, iconsModule];

export const moduleMap = Object.fromEntries(modules.map((m) => [m.id, m]));
</file>

<file path="src/ui/index.html">
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MB Tools</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Arial, sans-serif; margin: 0; color: #222; }
    .wrap { display: grid; grid-template-rows: 56px 1fr; height: 100vh; }
    header { display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-bottom: 1px solid #e5e5e5; }
    header img { height: 28px; width: 28px; }
    header h1 { font-size: 14px; margin: 0; font-weight: 600; }
    .main { display: grid; grid-template-columns: 120px 1fr; height: calc(100vh - 56px); }
    nav { border-right: 1px solid #e5e5e5; padding: 8px; display: flex; flex-direction: column; gap: 6px; }
    nav button { text-align: left; background: #f7f7f7; border: 1px solid #e5e5e5; border-radius: 6px; padding: 8px; font-size: 12px; cursor: pointer; }
    nav button.active { background: #eaeaea; border-color: #d2d2d2; }
    section { padding: 12px; }
    .hidden { display: none; }
    .status-box { width: 100%; padding: 10px; border-radius: 6px; text-align: center; font-weight: 500; }
    .status-default { background: #f5f5f5; color: #666; }
    .status-ready { background: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
    .status-busy { background: #e0e7ff; color: #3730a3; border: 1px solid #c7d2fe; }
    .btn { padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: #111; color: #fff; cursor: pointer; font-size: 12px; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    .muted { color: #666; font-size: 12px; }
    .vspace { height: 10px; }
    .list { max-height: 100px; overflow-y: auto; font-size: 12px; color: #c00; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <img src="assets/mb-logo.svg" alt="MB" />
      <h1>MB Tools</h1>
    </header>
    <div class="main">
      <nav>
        <button id="tab-style" class="active">Styles→Vars</button>
        <button id="tab-icons">Icon Rename</button>
      </nav>
      <section>
        <div id="panel-style">
          <p class="muted">Converter estilos de cor antigos para variables correspondentes.</p>
          <div class="vspace"></div>
          <div id="styleStatus" class="status-box status-default">Selecione ao menos um frame/section</div>
          <div class="vspace"></div>
          <button id="btnConvert" class="btn" disabled>Converter Seleção</button>
        </div>
        <div id="panel-icons" class="hidden">
          <p class="muted">Renomeia componentes selecionados para PascalCase com validação Lucide.</p>
          <div class="vspace"></div>
          <button id="btnRename" class="btn">Renomear Componentes</button>
          <div class="vspace"></div>
          <div id="iconsStatus" class="muted"></div>
          <div id="invalidList" class="list"></div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const tabStyle = document.getElementById('tab-style');
    const tabIcons = document.getElementById('tab-icons');
    const panelStyle = document.getElementById('panel-style');
    const panelIcons = document.getElementById('panel-icons');
    const styleStatus = document.getElementById('styleStatus');
    const btnConvert = document.getElementById('btnConvert');
    const btnRename = document.getElementById('btnRename');
    const iconsStatus = document.getElementById('iconsStatus');
    const invalidList = document.getElementById('invalidList');

    function showTab(tab) {
      if (tab === 'style') {
        tabStyle.classList.add('active');
        tabIcons.classList.remove('active');
        panelStyle.classList.remove('hidden');
        panelIcons.classList.add('hidden');
      } else {
        tabIcons.classList.add('active');
        tabStyle.classList.remove('active');
        panelIcons.classList.remove('hidden');
        panelStyle.classList.add('hidden');
      }
    }

    tabStyle.onclick = () => showTab('style');
    tabIcons.onclick = () => showTab('icons');

    // Style module state
    const styleState = { selectionState: 'none', styleCount: 0, isConverting: false };

    function updateStyleUI() {
      let text = 'Selecione ao menos um frame/section';
      let cls = 'status-default';
      if (styleState.isConverting) { text = 'Convertendo...'; cls = 'status-busy'; }
      else {
        if (styleState.selectionState === 'no-styles') text = 'Nenhum estilo detectado';
        else if (styleState.selectionState === 'ready') { text = `${styleState.styleCount} estilos detectados`; cls = 'status-ready'; }
      }
      styleStatus.textContent = text;
      styleStatus.className = `status-box ${cls}`;
      btnConvert.disabled = !(styleState.selectionState === 'ready' && !styleState.isConverting);
    }

    btnConvert.onclick = () => {
      styleState.isConverting = true;
      updateStyleUI();
      parent.postMessage({ pluginMessage: { module: 'style', type: 'convert' } }, '*');
    };

    // Icons module
    btnRename.onclick = () => {
      iconsStatus.textContent = 'Renomeando...';
      invalidList.textContent = '';
      parent.postMessage({ pluginMessage: { module: 'icons', type: 'rename-icons' } }, '*');
    };

    // Incoming messages
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;
      // Style
      if (msg.module === 'style') {
        switch (msg.type) {
          case 'selection-update':
            styleState.selectionState = !msg.hasSelection ? 'none' : (msg.count === 0 ? 'no-styles' : 'ready');
            styleState.styleCount = msg.count || 0;
            styleState.isConverting = false;
            updateStyleUI();
            break;
          case 'conversion-complete':
            styleState.isConverting = false;
            setTimeout(() => parent.postMessage({ pluginMessage: { module: 'style', type: 'check-selection' } }, '*'), 300);
            break;
          case 'error':
            styleState.isConverting = false;
            updateStyleUI();
            break;
        }
      }
      // Icons
      if (msg.module === 'icons') {
        if (msg.type === 'done') {
          if (msg.invalidNames && msg.invalidNames.length > 0) {
            iconsStatus.textContent = '⚠️ Alguns nomes são inválidos:';
            invalidList.innerHTML = msg.invalidNames.map((n) => `• ${n}`).join('<br/>');
          } else {
            iconsStatus.textContent = '✅ Todos os nomes são válidos!';
            invalidList.textContent = '';
          }
        }
      }
    };

    // Initial selection check for style module
    parent.postMessage({ pluginMessage: { module: 'style', type: 'check-selection' } }, '*');
  </script>
</body>
</html>
</file>

<file path="src/main.ts">
import { moduleMap, modules } from './modules';
import type { ModuleId, UIMsg } from './core/types';

figma.showUI(__html__, { width: 600, height: 400, title: 'MB Tools' });

// Init modules (listeners, etc.)
for (const m of modules) m.init?.();

figma.ui.onmessage = async (msg: UIMsg) => {
  const { module: moduleId, type, payload } = msg || ({} as UIMsg);
  const mod = moduleMap[moduleId as ModuleId];
  if (!mod) return;
  const handler = mod.handlers[type];
  if (!handler) return;
  await handler(payload);
};
</file>

<file path=".gitattributes">
# Normaliza quebras de linha para LF (Unix-style) em todos os arquivos de texto
* text=auto eol=lf

# Arquivos binários não devem ser modificados
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.svg binary
*.ico binary
*.pdf binary
*.woff binary
*.woff2 binary
*.ttf binary
</file>

<file path="build.js">
import { build, context } from 'esbuild';
import { mkdirSync, copyFileSync, readFileSync, writeFileSync } from 'fs';
import { dirname, resolve } from 'path';

const watch = process.argv.includes('--watch');

const options = {
  entryPoints: ['src/main.ts'],
  outfile: 'dist/code.js',
  bundle: true,
  // Figma plugin runtime lacks support for some modern syntax
  // Downlevel to avoid optional chaining/nullish coalescing in output
  // Target ES2017 to transpile object spread and newer syntax
  target: ['es2017'],
  platform: 'browser',
  format: 'cjs',
  sourcemap: false,
  minify: true,
  loader: { '.json': 'json' },
  logLevel: 'info'
};

async function bundle() {
  if (watch) {
    const ctx = await context(options);
    await ctx.watch();
    console.log('👀 Watching for changes...');
  } else {
    await build(options);
  }
}

function copyStatic() {
  try {
    mkdirSync('dist/assets', { recursive: true });
    // Prepare logo (prefer repo root mb-logo.svg)
    let logoSrc = resolve('..', 'mb-logo.svg');
    try {
      copyFileSync(logoSrc, resolve('dist/assets/mb-logo.svg'));
    } catch {
      logoSrc = resolve('assets/mb-logo.svg');
      copyFileSync(logoSrc, resolve('dist/assets/mb-logo.svg'));
    }
    const logoB64 = readFileSync(logoSrc).toString('base64');

    // Copy UI and inline logo as data URI for inline-HTML runtime
    const uiSrc = resolve('src/ui/index.html');
    const uiDest = resolve('dist/ui.html');
    const htmlRaw = readFileSync(uiSrc, 'utf-8');
    const html = htmlRaw.replace(
      /src\s*=\s*"assets\/mb-logo\.svg"/g,
      `src="data:image/svg+xml;base64,${logoB64}"`
    );
    writeFileSync(uiDest, html);

    console.log('📦 Copied static assets (logo inlined in UI)');
  } catch (e) {
    console.warn('⚠️ Failed to copy static assets:', e.message);
  }
}

await bundle();
copyStatic();
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Figma plugin called "MB Tools" that provides utilities for design system management. The plugin contains two main modules:

1. **Style to Variable Converter** (`style`) - Converts legacy color styles to design tokens/variables
2. **Icon Rename Tool** (`icons`) - Renames components to PascalCase with Lucide icon validation

## Architecture

The plugin follows a modular architecture:

- **Entry Point**: `src/main.ts` - Initializes all modules and handles UI message routing
- **Core Types**: `src/core/types.ts` - Defines the module system interfaces (`Module`, `UIMsg`, `Handler`)
- **Module System**: `src/modules/index.ts` - Exports all available modules and creates a module map
- **Individual Modules**: Each module in `src/modules/*/` implements the `Module` interface with:
  - `id`: Unique identifier matching `ModuleId` type
  - `name`: Display name
  - `init()`: Optional initialization (e.g., event listeners)
  - `handlers`: Object mapping message types to handler functions

## Development Commands

```bash
# Build the plugin for production
npm run build

# Build and watch for changes during development
npm run watch

# Clean build artifacts
npm run clean
```

## Build Process

The build system (`build.js`) uses esbuild to:

- Bundle `src/main.ts` into `dist/code.js` (Figma plugin code)
- Copy and process `src/ui/index.html` to `dist/ui.html` (plugin UI)
- Inline the MB logo SVG as base64 data URI in the UI
- Target ES2017 for Figma plugin compatibility
- Minify output for production

## Plugin Structure

- **Manifest**: `manifest.json` defines plugin metadata for Figma
- **TypeScript Config**: Targets ES2019 with strict mode enabled
- **UI**: Single HTML file with embedded CSS and JavaScript
- **Assets**: Logo files processed during build (prefers `../mb-logo.svg`, falls back to `assets/mb-logo.svg`)

## Adding New Modules

1. Create a new directory under `src/modules/your-module/`
2. Implement a `main.ts` that exports a `Module` object
3. Add the module ID to the `ModuleId` union type in `src/core/types.ts`
4. Import and add the module to the `modules` array in `src/modules/index.ts`
5. Add corresponding UI elements and handlers in `src/ui/index.html`

## Module Communication

UI ↔ Plugin communication uses `postMessage` with typed messages:
- UI sends: `{ module: ModuleId, type: string, payload?: any }`
- Plugin responds via `figma.ui.postMessage()`
- Message routing handled automatically in `main.ts`

## External Dependencies

The icon rename module depends on a Lucide names JSON file at `../../../../mbIconRename/lucide-names.json` for validation.
</file>

<file path="manifest.json">
{
  "name": "MB Tools",
  "id": "mb-tools-unified",
  "api": "1.0.0",
  "main": "dist/code.js",
  "ui": "dist/ui.html",
  "editorType": ["figma"],
  "documentAccess": "dynamic-page",
  "networkAccess": {
    "allowedDomains": ["none"]
  }
}
</file>

<file path="package.json">
{
  "name": "mb-tools",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "node build.js",
    "watch": "node build.js --watch",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "esbuild": "^0.20.0"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2019",
    "module": "ESNext",
    "moduleResolution": "Node",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "outDir": "dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
</file>

</files>
